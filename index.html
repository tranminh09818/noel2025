<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Golden Christmas - Ultimate Edition</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel+Decorative:wght@700&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Cinzel Decorative', serif; user-select: none; }
        
        /* C√°i v√≤ng xoay xoay l√∫c m·ªõi v√†o */
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; display: flex; flex-direction: column;
            align-items: center; justify-content: center; z-index: 999;
            transition: opacity 1s ease-out;
        }
        .spinner {
            width: 60px; height: 60px; border: 2px solid rgba(212,175,55,0.1);
            border-radius: 50%; border-top-color: #D4AF37;
            animation: spin 1s infinite linear;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        #loader-text { margin-top: 15px; color: #D4AF37; letter-spacing: 3px; font-size: 12px; }

        /* Ch·ªØ Merry Christmas to ƒë√πng */
        #main-title {
            position: absolute; top: 8%; width: 100%; text-align: center;
            color: #FFD700; font-size: 28px; letter-spacing: 8px; opacity: 0.9; 
            text-transform: uppercase; 
            text-shadow: 0 0 15px rgba(255, 215, 0, 0.8), 0 0 30px rgba(255, 165, 0, 0.6);
            pointer-events: none; transition: opacity 0.5s, transform 0.5s;
            z-index: 5;
        }
        
        /* Khung camera ·ªü g√≥c d∆∞·ªõi */
        #cam-container {
            position: absolute; bottom: 20px; left: 20px; width: 220px; height: 165px;
            border-radius: 12px; overflow: hidden; 
            border: 2px solid #D4AF37; 
            box-shadow: 0 0 25px rgba(212, 175, 55, 0.5); 
            transform: scaleX(-1); /* L·∫≠t ng∆∞·ª£c cho gi·ªëng g∆∞∆°ng */
            z-index: 10;
            transition: width 0.3s, height 0.3s;
        }
        #cam-preview { 
            width: 100%; height: 100%; object-fit: cover; 
            /* Filter c√† da m·∫∑t cho xinh */
            filter: brightness(1.25) saturate(1.3) contrast(1.05) sepia(0.15) blur(0.8px);
        }
        /* V·∫Ω m·∫•y c√°i x∆∞∆°ng tay l√™n ƒë√¢y */
        #hand-canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 12; pointer-events: none;
        }
        /* L√†m t·ªëi 4 g√≥c camera cho ngh·ªá thu·∫≠t */
        #cam-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, rgba(255, 215, 0, 0.1) 20%, rgba(60, 40, 0, 0.3) 80%, rgba(0,0,0,0.8) 100%);
            box-shadow: inset 0 0 20px rgba(255, 215, 0, 0.3);
            pointer-events: none; z-index: 11; mix-blend-mode: overlay;
        }
        
        /* B·∫£ng h∆∞·ªõng d·∫´n c√°ch d√πng */
        #gesture-debug {
            position: absolute; bottom: 200px; left: 20px;
            color: #FFD700; font-family: 'Courier New', monospace; font-size: 11px;
            text-shadow: 0 0 2px #000; pointer-events: none;
            line-height: 1.6; background: rgba(0,0,0,0.6);
            padding: 10px; border-radius: 8px; border-left: 2px solid #D4AF37;
        }

        /* N√∫t b·∫•m nh√¨n k√≠nh k√≠nh ·∫£o ·∫£o */
        .glass-btn {
            background: rgba(0,0,0,0.6); border: 1px solid #D4AF37; color: #D4AF37;
            padding: 10px 20px; border-radius: 25px; cursor: pointer;
            font-family: 'Cinzel Decorative', serif; font-size: 12px; letter-spacing: 2px;
            transition: 0.3s; backdrop-filter: blur(5px); display: flex; align-items: center; gap: 8px;
        }
        .glass-btn:hover { background: #D4AF37; color: #000; box-shadow: 0 0 20px #D4AF37; }

        #ai-btn { position: absolute; bottom: 30px; right: 30px; z-index: 20; }

        /* C√°i b·∫£ng nh·∫≠p ƒëi·ªÅu ∆∞·ªõc hi·ªán ra gi·ªØa m√†n h√¨nh */
        #ai-modal {
            display: none; position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%); width: 320px;
            background: rgba(15,15,15,0.95); border: 1px solid #D4AF37;
            padding: 40px; text-align: center; z-index: 100; 
            box-shadow: 0 0 60px rgba(212, 175, 55, 0.2); border-radius: 12px;
        }
        #ai-input {
            width: 100%; padding: 12px; margin: 20px 0; background: #222;
            border: 1px solid #555; color: #D4AF37; text-align: center; outline: none;
            box-sizing: border-box; font-family: 'Cinzel Decorative', serif;
        }
        #ai-submit {
            background: #D4AF37; border: none; padding: 10px 25px; cursor: pointer; font-weight: bold;
            color: #000; transition: 0.2s; font-family: 'Cinzel Decorative', serif;
        }
        #ai-submit:hover { background: #fff; box-shadow: 0 0 15px #fff; }
        #ai-close { position: absolute; top: 15px; right: 20px; color: #666; cursor: pointer; font-family: sans-serif; font-size: 20px;}
        
        #upload-btn {
            background: transparent; border: 1px solid #D4AF37; color: #D4AF37;
            padding: 8px 20px; cursor: pointer; border-radius: 20px;
            font-size: 11px; letter-spacing: 1px; transition: 0.2s;
            margin-top: 15px; font-family: 'Cinzel Decorative', serif;
        }
        #upload-btn:hover { background: #D4AF37; color: #000; }

        /* Ch·ªõp tr·∫Øng khi ch·ª•p ·∫£nh */
        #flash-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: white; opacity: 0; pointer-events: none; z-index: 2000;
            transition: opacity 0.1s ease-out;
        }
    </style>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <div id="loader-text">LOADING GOLDEN MAGIC...</div>
    </div>

    <div id="main-title">MERRY CHRISTMAS</div>

    <div id="cam-container">
        <video id="cam-preview" playsinline autoplay muted></video>
        <canvas id="hand-canvas"></canvas>
        <div id="cam-overlay"></div>
    </div>
    
    <div id="gesture-debug">
        Waiting for Hand...<br>
         ‚úå 2 Ng√≥n: Gi·ªØ 3s hi·ªán CH·ªÆ<br>
         ‚òù 1 Ng√≥n: Gi·ªØ 3s v·ªÅ C√ÇY<br>
         üëç Like: Ch·ª•p (5s) | üëå Ch·ª•m: Zoom
    </div>

    <button id="ai-btn" class="glass-btn" onclick="app.toggleAI()">‚ú® AI WISH & PHOTOS</button>

    <div id="ai-modal">
        <span id="ai-close" onclick="app.toggleAI()">‚úï</span>
        <h3 style="color:#D4AF37; margin:0; letter-spacing: 2px;">MAKE A WISH</h3>
        <p style="color:#888; font-size: 10px; margin-bottom: 5px;">(AI or Direct Text)</p>
        <input type="text" id="ai-input" placeholder="e.g. Peace & Love">
        <button id="ai-submit" onclick="app.askGemini()">CAST SPELL</button>
        <hr style="border-top: 1px dashed #333; border-bottom: none; margin: 25px 0 15px 0;">
        <h3 style="color:#D4AF37; margin:0; letter-spacing: 2px; font-size: 14px;">YOUR MEMORIES</h3>
        <p style="color:#888; font-size: 10px; margin: 5px 0 10px 0;">Upload photos to replace frames</p>
        <input type="file" id="img-upload" accept="image/*" multiple style="display: none;" onchange="app.uploadImages(this)">
        <button id="upload-btn" onclick="document.getElementById('img-upload').click()"> SELECT PHOTOS</button>
    </div>

    <div id="flash-overlay"></div>

    <audio id="shutter-sound">
        <source src="https://cdn.pixabay.com/download/audio/2022/03/10/audio_c8c8a73467.mp3" type="audio/mpeg">
    </audio>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
        import { MeshSurfaceSampler } from 'three/addons/math/MeshSurfaceSampler.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilesetResolver, HandLandmarker } from "@mediapipe/tasks-vision";

        class ChristmasGestures {
            constructor() {
                // C·∫•u h√¨nh m·∫•y c√°i h·∫°t, tuy·∫øt, m√†u s·∫Øc ·ªü ƒë√¢y
                this.config = {
                    particleCount: 6500, 
                    snowCount: 900,
                    frameCount: 8,
                    colors: [
                        0xFFD700, 0xFFE5B4, 0xDAA520, 0xFFFFE0, 0xB8860B, // V√†ng
                        0xFF0000, 0xDC143C, // ƒê·ªè
                        0x228B22 // Xanh l√° (√≠t th√¥i)
                    ] 
                };

                // Tr·∫°ng th√°i hi·ªán t·∫°i c·ªßa web (ƒëang zoom bao nhi√™u, xoay th·∫ø n√†o...)
                this.state = {
                    mode: 'tree', 
                    zoom: 1.0,    
                    rotationSpeed: 0.1, 
                    targetRotationSpeed: 0.1,
                    frameScale: 1.0, 
                    handDetected: false,
                    hoveredFrameIndex: -1
                };

                this.positions = { tree: [], text: [], explosion: [] };
                this.particles = [];
                this.frames = []; 
                this.dummy = new THREE.Object3D(); 
                this.apiKey = localStorage.getItem("gemini_api_key") || ""; 

                // Bi·∫øn d√πng ƒë·ªÉ t√≠nh to√°n c·ª≠ ch·ªâ tay
                this.lastShakeX = 0; 
                this.shakeCounter = 0;
                this.lastTime = 0;
                this.lastPredictionTime = 0; 
                this.mouse = new THREE.Vector2(999, 999);
                this.raycaster = new THREE.Raycaster(); 
                this.morphTimeout = null; 
                
                // ƒê·ªìng h·ªì ƒë·∫øm gi·ªù cho m·∫•y c√°i gi·ªØ tay
                this.holdStart = 0;      
                this.twoFingerStart = 0; 
                this.likeStart = 0;      
                this.isTakingScreenshot = false;
                
                this.onResize = this.onResize.bind(this);

                // G·ªçi m·∫•y h√†m kh·ªüi t·∫°o
                this.initThree();          
                this.initPostProcessing(); 
                this.initParticles();      
                this.initFrames();         
                this.initSnow();           
                this.initAI();             

                // T·∫£i font xong th√¨ m·ªõi cho ch·∫°y
                new FontLoader().load('https://threejs.org/examples/fonts/optimer_bold.typeface.json', (font) => {
                    this.loadedFont = font;
                    this.calculatePositions(font).then(() => {
                        this.targetPositions = this.positions.tree;
                        document.getElementById('loader').style.opacity = 0;
                        setTimeout(() => {
                            const l = document.getElementById('loader');
                            if(l) l.remove();
                        }, 1000);
                        this.animate();
                    });
                });

                window.addEventListener('resize', this.onResize);
                window.addEventListener('mousemove', (e) => {
                    if (!this.state.handDetected) {
                        this.mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                        this.mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                        this.state.targetRotationSpeed = (this.mouse.x + 1) * 0.5;
                    }
                });
            }

            // Kh·ªüi t·∫°o s√¢n kh·∫•u 3D
            initThree() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x000000);
                this.scene.fog = new THREE.FogExp2(0x000000, 0.015);

                this.camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 0, 90);

                this.renderer = new THREE.WebGLRenderer({ 
                    antialias: false, 
                    powerPreference: "high-performance",
                    preserveDrawingBuffer: true 
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.outputColorSpace = THREE.SRGBColorSpace; 
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                document.body.appendChild(this.renderer.domElement);

                this.scene.add(new THREE.AmbientLight(0xffffff, 0.8)); 
                const dirLight = new THREE.DirectionalLight(0xffffff, 2.5);
                dirLight.position.set(0, 50, 50);
                this.scene.add(dirLight);

                const starGeo = new THREE.IcosahedronGeometry(1.5, 0);
                const starMat = new THREE.MeshBasicMaterial({ color: 0xFFFF00 });
                this.starMesh = new THREE.Mesh(starGeo, starMat);
                this.starMesh.position.set(0, 32, 0); 
                this.scene.add(this.starMesh);
            }

            // Hi·ªáu ·ª©ng ph√°t s√°ng l·∫•p l√°nh (Bloom)
            initPostProcessing() {
                this.composer = new EffectComposer(this.renderer);
                this.composer.addPass(new RenderPass(this.scene, this.camera));
                this.bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                this.bloomPass.threshold = 0.85; 
                this.bloomPass.strength = 1.2;
                this.bloomPass.radius = 0.5;
                this.composer.addPass(this.bloomPass);
            }

            // T·∫°o c√°c h·∫°t nh·ªè (c·∫•u th√†nh n√™n c√¢y th√¥ng)
            initParticles() {
                const geo = new THREE.SphereGeometry(0.12, 6, 6);
                const mat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                this.instancedMesh = new THREE.InstancedMesh(geo, mat, this.config.particleCount);
                this.scene.add(this.instancedMesh);

                this.particles = [];

                for(let i=0; i<this.config.particleCount; i++) {
                    const rawColor = this.config.colors[Math.floor(Math.random()*this.config.colors.length)];
                    const color = new THREE.Color(rawColor);
                    
                    const isGreen = (rawColor === 0x228B22); 
                    if (!isGreen) color.offsetHSL(0, 0, Math.random()*0.4); 
                    else color.offsetHSL(0, 0, Math.random()*0.1);
                    
                    this.instancedMesh.setColorAt(i, color);

                    const pos = new THREE.Vector3((Math.random()-0.5)*200, (Math.random()-0.5)*100, (Math.random()-0.5)*100);
                    const isBig = Math.random() < 0.1; 
                    const scale = isBig ? (2.5 + Math.random() * 2.0) : (0.5 + Math.random());

                    this.particles.push({
                        current: pos.clone(),
                        velocity: new THREE.Vector3(),
                        originalColor: color.clone(),
                        baseScale: scale,
                        phase: Math.random() * Math.PI * 2,
                        speed: 0.03 + Math.random() * 0.03,
                        isGreen: isGreen
                    });
                    
                    this.dummy.position.copy(pos);
                    this.dummy.updateMatrix();
                    this.instancedMesh.setMatrixAt(i, this.dummy.matrix);
                }
                this.instancedMesh.instanceColor.needsUpdate = true;
            }

            // T·∫°o m·∫•y c√°i khung ·∫£nh treo tr√™n c√¢y
            initFrames() {
                const borderGeo = new THREE.BoxGeometry(4.2, 4.9, 0.1); 
                const borderMat = new THREE.MeshStandardMaterial({
                    color: 0xFFC125, emissive: 0xFFC125, emissiveIntensity: 0.2, roughness: 0.3, metalness: 0.8
                });
                const photoGeo = new THREE.PlaneGeometry(4, 4.7);
                const photoMat = new THREE.MeshBasicMaterial({ color: 0xffffff });

                const genTex = (txt) => {
                    const c = document.createElement('canvas'); c.width=512; c.height=640; 
                    const x = c.getContext('2d');
                    x.fillStyle='#000'; x.fillRect(0,0,512,640); 
                    x.fillStyle='#FFD700'; x.font='100px "Times New Roman"'; x.textAlign='center'; 
                    x.fillText('‚òÖ', 256, 280);
                    x.font='48px "Times New Roman"'; x.fillText(txt, 256, 400);
                    const tex = new THREE.CanvasTexture(c);
                    tex.colorSpace = THREE.SRGBColorSpace; 
                    tex.minFilter = THREE.LinearFilter; 
                    return tex;
                };

                const goldenAngle = Math.PI * (3 - Math.sqrt(5)); 

                for(let i=0; i<this.config.frameCount; i++) {
                    const group = new THREE.Group();
                    const borderMesh = new THREE.Mesh(borderGeo, borderMat.clone());
                    group.add(borderMesh);
                    const photoMesh = new THREE.Mesh(photoGeo, photoMat.clone());
                    photoMesh.position.z = 0.06;
                    photoMesh.name = "photoContent"; 
                    photoMesh.material.map = genTex(i%2==0 ? "HOPE" : "JOY");
                    group.add(photoMesh);
                    this.scene.add(group);
                    
                    const y = 20 - (i / (this.config.frameCount - 1)) * 40; 
                    const theta = i * goldenAngle * 3; 
                    
                    this.frames.push({ 
                        mesh: group, baseTheta: theta, baseY: y, baseScale: 1, currentScale: 1
                    });
                }
            }

            // T·∫°o tuy·∫øt r∆°i
            initSnow() {
                const cvs = document.createElement('canvas'); cvs.width=32; cvs.height=32;
                const ctx = cvs.getContext('2d');
                const grd = ctx.createRadialGradient(16,16,0,16,16,16);
                grd.addColorStop(0,'rgba(255,255,255,0.9)'); grd.addColorStop(1,'rgba(255,255,255,0)');
                ctx.fillStyle=grd; ctx.fillRect(0,0,32,32);
                
                const geo = new THREE.BufferGeometry();
                const pos = []; this.snowVel = [];
                for(let i=0; i<this.config.snowCount; i++){
                    pos.push((Math.random()-0.5)*300, (Math.random()-0.5)*200, (Math.random()-0.5)*100);
                    this.snowVel.push({y: 0.05 + Math.random()*0.1, x: Math.random()*100, sway: Math.random() * Math.PI});
                }
                geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
                const mat = new THREE.PointsMaterial({ size: 1.2, map: new THREE.CanvasTexture(cvs), transparent: true, opacity: 0.7, depthWrite: false, blending: THREE.AdditiveBlending });
                this.snowSystem = new THREE.Points(geo, mat);
                this.scene.add(this.snowSystem);
            }

            // T√≠nh to√°n v·ªã tr√≠ c√°c h·∫°t ƒë·ªÉ x·∫øp th√†nh C√¢y
            async calculatePositions(font) {
                const treeArr = [];
                const h=70, maxR=25;
                for(let i=0; i<this.config.particleCount; i++) {
                    const p = i/this.config.particleCount;
                    const y = 30 - p*h;
                    const r = Math.pow(p, 0.8) * maxR; 
                    const theta = i * 2.39996;
                    const rVar = r * Math.sqrt(Math.random());
                    treeArr.push(new THREE.Vector3(Math.cos(theta)*rVar, y, Math.sin(theta)*rVar));
                }
                this.positions.tree = treeArr;
                await this.updateText("MERRY CHRISTMAS");
            }

            // T√≠nh to√°n v·ªã tr√≠ c√°c h·∫°t ƒë·ªÉ x·∫øp th√†nh Ch·ªØ
            updateText(str) {
                return new Promise(resolve => {
                    const arr = [];
                    const config = { font: this.loadedFont, size: 8, height: 0.3, curveSegments: 4 };
                    const geo = new TextGeometry(str, config);
                    geo.center();
                    const sampler = new MeshSurfaceSampler(new THREE.Mesh(geo)).build();
                    const tmp = new THREE.Vector3();
                    for(let i=0; i<this.config.particleCount; i++) {
                        sampler.sample(tmp); arr.push(tmp.clone());
                    }
                    this.positions.text = arr;
                    resolve();
                });
            }

            // M·∫•y h√†m b·∫≠t/t·∫Øt c√°i b·∫£ng nh·∫≠p ƒëi·ªÅu ∆∞·ªõc
            toggleAI() {
                const el = document.getElementById('ai-modal');
                el.style.display = el.style.display === 'block' ? 'none' : 'block';
            }

            // H√†m g·ªçi AI ƒë·ªÉ t·∫°o c√¢u ch√∫c (ho·∫∑c d√πng text b·∫°n nh·∫≠p)
            async askGemini() {
                const input = document.getElementById('ai-input').value;
                if(!input) return;

                if (!this.apiKey) {
                    const key = prompt("Nh·∫≠p Gemini API Key (N·∫øu c√≥) ƒë·ªÉ t·∫°o c√¢u ch√∫c AI:");
                    if (key) {
                        this.apiKey = key;
                        localStorage.setItem("gemini_api_key", key);
                    }
                }

                const btn = document.getElementById('ai-submit');
                const prevText = btn.innerText;
                btn.innerText = "ƒêANG T·∫†O...";
                
                let finalText = input.toUpperCase(); 

                if (this.apiKey) {
                    try {
                        const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${this.apiKey}`, {
                            method: 'POST', headers: {'Content-Type':'application/json'},
                            body: JSON.stringify({
                                contents:[{parts:[{text: `User wish: "${input}". Create a very short, 2-3 word magical Christmas phrase based on this. Return ONLY JSON: {"text":"THE_PHRASE"}` }] }],
                                generationConfig: { responseMimeType: "application/json" }
                            })
                        });
                        
                        if (res.ok) {
                            const d = await res.json();
                            finalText = JSON.parse(d.candidates[0].content.parts[0].text).text;
                        }
                    } catch(e) { console.warn("AI l·ªói, d√πng text g·ªëc"); } 
                }

                await this.updateText(finalText);
                this.triggerMorph(true, 'text');
                
                setTimeout(() => {
                    this.state.mode = 'text';
                    document.getElementById('main-title').innerText = finalText;
                    this.toggleAI();
                }, 1000);

                btn.innerText = prevText;
            }

            // H√†m t·∫£i ·∫£nh l√™n khung tranh
            uploadImages(input) {
                if (input.files && input.files.length > 0) {
                    const files = Array.from(input.files);
                    const btn = document.getElementById('upload-btn');
                    btn.innerText = "ƒêANG T·∫¢I ·∫¢NH...";
                    
                    Promise.all(files.map(file => {
                        return new Promise(resolve => {
                            const reader = new FileReader();
                            reader.onload = (e) => {
                                const img = new Image();
                                img.src = e.target.result;
                                img.onload = () => {
                                    const tex = new THREE.Texture(img);
                                    tex.needsUpdate = true;
                                    tex.colorSpace = THREE.SRGBColorSpace;
                                    tex.minFilter = THREE.LinearFilter; 
                                    tex.magFilter = THREE.LinearFilter;
                                    tex.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
                                    resolve(tex);
                                };
                            };
                            reader.readAsDataURL(file);
                        });
                    })).then(textures => {
                        this.frames.forEach((f, i) => {
                            const tex = textures[i % textures.length];
                            const photoMesh = f.mesh.getObjectByName('photoContent');
                            if (photoMesh) {
                                photoMesh.material.map = tex;
                                photoMesh.material.needsUpdate = true;
                            }
                        });
                        btn.innerText = "ƒê√É C·∫¨P NH·∫¨T!";
                        setTimeout(() => { 
                            btn.innerText = "CH·ªåN ·∫¢NH"; 
                            this.toggleAI(); 
                        }, 1500);
                    });
                }
            }

            // Kh·ªüi ƒë·ªông Camera v√† AI nh·∫≠n di·ªán tay
            async initAI() {
                try {
                    const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
                    this.handLandmarker = await HandLandmarker.createFromOptions(vision, {
                        baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task", delegate: "GPU" },
                        runningMode: "VIDEO", numHands: 1
                    });
                    const vid = document.getElementById('cam-preview');
                    const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                    vid.srcObject = stream;
                    vid.addEventListener("loadeddata", () => this.predictWebcam());
                } catch(e) { 
                    console.error("Cam Error", e); 
                    document.getElementById('gesture-debug').innerHTML = "Camera Denied. Using Mouse Mode.";
                }
            }

            predictWebcam() {
                const vid = document.getElementById('cam-preview');
                const now = performance.now();
                if(this.handLandmarker && vid.currentTime !== this.lastTime && (now - this.lastPredictionTime > 60)) {
                    this.lastTime = vid.currentTime;
                    this.lastPredictionTime = now;
                    const result = this.handLandmarker.detectForVideo(vid, now);
                    this.processGestures(result, now);
                }
                requestAnimationFrame(() => this.predictWebcam());
            }

            // V·∫Ω b·ªô x∆∞∆°ng tay m√†u ƒë·ªè l√™n m√†n h√¨nh
            drawHandSkeleton(landmarks) {
                const canvas = document.getElementById('hand-canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                ctx.strokeStyle = '#FF0000'; // M√†u ƒê·ªé
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                const connections = [[0, 1], [1, 2], [2, 3], [3, 4], [0, 5], [5, 6], [6, 7], [7, 8], [5, 9], [9, 10], [10, 11], [11, 12], [9, 13], [13, 14], [14, 15], [15, 16], [13, 17], [17, 18], [18, 19], [19, 20], [0, 17]];

                connections.forEach(([i, j]) => {
                    const p1 = landmarks[i];
                    const p2 = landmarks[j];
                    ctx.beginPath();
                    ctx.moveTo(p1.x * canvas.width, p1.y * canvas.height);
                    ctx.lineTo(p2.x * canvas.width, p2.y * canvas.height);
                    ctx.stroke();
                });

                ctx.fillStyle = '#FF0000';
                for(let lm of landmarks) {
                    ctx.beginPath();
                    ctx.arc(lm.x * canvas.width, lm.y * canvas.height, 4, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }

            // --- X·ª¨ L√ù C√ÅC C·ª¨ CH·ªà TAY ---
            processGestures(result, now) {
                const statusEl = document.getElementById('gesture-debug');
                
                if (result.landmarks.length > 0) {
                    this.state.handDetected = true; 
                    const lm = result.landmarks[0]; 
                    this.drawHandSkeleton(lm);

                    let fingerCount = 0;
                    if (lm[8].y < lm[6].y) fingerCount++; 
                    if (lm[12].y < lm[10].y) fingerCount++; 
                    if (lm[16].y < lm[14].y) fingerCount++; 
                    if (lm[20].y < lm[18].y) fingerCount++; 
                    
                    const thumbDist = Math.hypot(lm[4].x - lm[0].x, lm[4].y - lm[0].y);
                    const indexDist = Math.hypot(lm[5].x - lm[0].x, lm[5].y - lm[0].y);
                    const isThumbExtended = (thumbDist > indexDist * 1.1);
                    if (isThumbExtended) fingerCount++; 

                    const pinchDist = Math.hypot(lm[8].x - lm[4].x, lm[8].y - lm[4].y);
                    const targetScale = THREE.MathUtils.clamp(THREE.MathUtils.mapLinear(pinchDist, 0.05, 0.3, 0.5, 4.0), 0.5, 4.0);
                    this.state.frameScale += (targetScale - this.state.frameScale) * 0.1;

                    // Ki·ªÉm tra c·ª≠ ch·ªâ Like ch·∫∑t ch·∫Ω
                    const isFingersCurled = (lm[8].y > lm[6].y) && (lm[12].y > lm[10].y) && (lm[16].y > lm[14].y) && (lm[20].y > lm[18].y);
                    const isThumbHigh = (lm[4].y < lm[3].y) && (lm[4].y < lm[5].y);
                    const isThumbUp = isThumbExtended && isFingersCurled && isThumbHigh;

                    // LIKE (5s) -> CH·ª§P ·∫¢NH
                    if (isThumbUp && !this.isTakingScreenshot) {
                        this.holdStart = 0; 
                        this.twoFingerStart = 0;
                        if (this.likeStart === 0) this.likeStart = now;
                        const elapsed = now - this.likeStart;
                        if (elapsed > 5000) { // 5 gi√¢y
                            this.takeScreenshot();
                            this.likeStart = 0;
                        } else {
                            const timeLeft = Math.ceil((5000 - elapsed)/1000);
                            statusEl.innerHTML = `üì∏ CH·ª§P ·∫¢NH SAU ${timeLeft}s (GI·ªÆ LIKE)`;
                        }
                        return; 
                    } else {
                        this.likeStart = 0; 
                    }

                    // 2 NG√ìN (3s) -> HI·ªÜN CH·ªÆ
                    if (fingerCount === 2) {
                        if (this.state.mode !== 'text' && this.state.mode !== 'morphing') {
                            if (this.twoFingerStart === 0) this.twoFingerStart = now;
                            const elapsed = now - this.twoFingerStart;
                            if (elapsed > 3000) {
                                this.triggerMorph(true, 'text'); 
                                this.twoFingerStart = 0;
                            } else {
                                const timeLeft = Math.ceil((3000 - elapsed)/1000);
                                statusEl.innerHTML = `‚úå GI·ªÆ 2 NG√ìN ${timeLeft}s HI·ªÜN CH·ªÆ`;
                            }
                        } else {
                            this.twoFingerStart = 0;
                            statusEl.innerHTML = `‚úå 2 NG√ìN: ƒêANG HI·ªÜN CH·ªÆ`;
                        }
                        this.holdStart = 0; 
                    }

                    // 1 NG√ìN (3s) -> V·ªÄ C√ÇY
                    else if (fingerCount === 1) {
                        this.twoFingerStart = 0; 
                        if (this.state.mode !== 'tree' && this.state.mode !== 'morphing') {
                            if (this.holdStart === 0) this.holdStart = now; 
                            const elapsed = now - this.holdStart;
                            if (elapsed > 3000) { 
                                 this.triggerMorph(true, 'tree'); 
                                 this.holdStart = 0; 
                            } else {
                                 const timeLeft = Math.ceil((3000 - elapsed)/1000);
                                 statusEl.innerHTML = `‚òù GI·ªÆ Y√äN ${timeLeft}s ƒê·ªÇ V·ªÄ C√ÇY TH√îNG`;
                            }
                        } else {
                            this.holdStart = 0; 
                            const currentX = lm[8].x;
                            if (Math.abs(currentX - this.lastShakeX) > 0.05) { 
                                 this.shakeCounter++;
                            } else {
                                 this.shakeCounter = Math.max(0, this.shakeCounter - 1);
                            }
                            if (this.shakeCounter > 3) { 
                                this.triggerMorph(true, 'tree'); 
                                this.shakeCounter = 0;
                            }
                            this.lastShakeX = currentX;
                            statusEl.innerHTML = "‚òù 1 NG√ìN: C√ÇY | üëã L·∫ÆC M·∫†NH = B√ôM";
                        }
                    } else {
                        // C√ÅC C·ª¨ CH·ªà KH√ÅC
                        this.holdStart = 0;
                        this.twoFingerStart = 0;
                        if (fingerCount === 0) {
                            this.state.zoom += (1.0 - this.state.zoom) * 0.05; 
                            statusEl.innerHTML = "‚úä N·∫ÆM TAY: THU L·∫†I (RESET)";
                        } else if (fingerCount === 5) {
                            this.state.zoom += (2.5 - this.state.zoom) * 0.05; 
                            statusEl.innerHTML = "üñê 5 NG√ìN: ZOOM | üëã L·∫ÆC M·∫†NH = B√ôM";
                        } else {
                            statusEl.innerHTML = `üëå CH·ª§M 2 NG√ìN: ZOOM ƒê·ªÄU`;
                        }
                    }

                    // Xoay Camera theo tay
                    const rotDx = lm[9].x - lm[0].x;
                    const rotDy = lm[9].y - lm[0].y;
                    const angle = Math.atan2(rotDy, rotDx);
                    this.state.targetRotationSpeed = (angle + Math.PI/2) * 2.0; 

                } else {
                    // Kh√¥ng c√≥ tay -> Xoay ch·∫≠m
                    this.state.handDetected = false; 
                    this.holdStart = 0;
                    this.likeStart = 0;
                    this.twoFingerStart = 0;
                    this.state.targetRotationSpeed = 0.05; 
                    const cvs = document.getElementById('hand-canvas');
                    cvs.getContext('2d').clearRect(0,0,cvs.width, cvs.height);
                    statusEl.innerHTML = "ƒêang t√¨m b√†n tay... (C√≥ th·ªÉ d√πng chu·ªôt)";
                }
            }

            // Ch·ª•p ·∫£nh m√†n h√¨nh
            takeScreenshot() {
                if (this.isTakingScreenshot) return;
                this.isTakingScreenshot = true;
                const flash = document.getElementById('flash-overlay');
                const shutter = document.getElementById('shutter-sound');
                const statusEl = document.getElementById('gesture-debug');
                
                shutter.currentTime = 0;
                shutter.play().catch(e => console.log("Audio play failed"));
                flash.style.opacity = 1;
                statusEl.innerHTML = "üì∏ ƒêANG CH·ª§P...";

                setTimeout(() => {
                    flash.style.opacity = 0;
                    this.renderer.render(this.scene, this.camera);
                    const compositeCanvas = document.createElement('canvas');
                    compositeCanvas.width = window.innerWidth;
                    compositeCanvas.height = window.innerHeight;
                    const ctx = compositeCanvas.getContext('2d');
                    
                    const video = document.getElementById('cam-preview');
                    ctx.save();
                    ctx.translate(compositeCanvas.width, 0);
                    ctx.scale(-1, 1);
                    ctx.filter = 'brightness(1.25) saturate(1.3) contrast(1.05) sepia(0.15) blur(0.8px)';
                    ctx.drawImage(video, 0, 0, compositeCanvas.width, compositeCanvas.height);
                    
                    const handCanvas = document.getElementById('hand-canvas');
                    ctx.drawImage(handCanvas, 0, 0, compositeCanvas.width, compositeCanvas.height);
                    ctx.restore();
                    
                    ctx.filter = 'none'; 
                    ctx.drawImage(this.renderer.domElement, 0, 0);
                    
                    const title = document.getElementById('main-title');
                    ctx.font = '28px "Cinzel Decorative", serif';
                    ctx.fillStyle = '#FFD700';
                    ctx.textAlign = 'center';
                    ctx.fillText(title.innerText, compositeCanvas.width/2, compositeCanvas.height * 0.15);

                    const dataURL = compositeCanvas.toDataURL('image/jpeg', 0.9);
                    const link = document.createElement('a');
                    link.href = dataURL;
                    link.download = 'Golden-Christmas-Moment.jpg';
                    link.click();
                    
                    this.isTakingScreenshot = false;
                    statusEl.innerHTML = "‚úÖ ƒê√É L∆ØU ·∫¢NH!";
                }, 150);
            }

            // Hi·ªáu ·ª©ng n·ªï h·∫°t & chuy·ªÉn c·∫£nh
            triggerMorph(isBigExplosion = true, targetMode = 'tree') {
                if(this.state.mode === 'morphing') return;
                this.state.mode = 'morphing';
                
                this.particles.forEach(p => {
                    const dir = p.current.clone().normalize();
                    const force = isBigExplosion ? (1.5 + Math.random() * 1.5) : (0.1 + Math.random() * 0.1);
                    p.velocity.add(dir.multiplyScalar(force));
                });

                if (this.morphTimeout) clearTimeout(this.morphTimeout);
                this.morphTimeout = setTimeout(() => {
                    this.state.mode = targetMode;
                    if (targetMode === 'tree') {
                        this.targetPositions = this.positions.tree;
                        document.getElementById('main-title').innerText = "MERRY CHRISTMAS";
                    } else if (targetMode === 'text') {
                        this.targetPositions = this.positions.text;
                    }
                }, 2000); 
            }

            // V√≤ng l·∫∑p chuy·ªÉn ƒë·ªông
            animate() {
                requestAnimationFrame(() => this.animate());
                const time = performance.now() * 0.001;

                if (this.starMesh) {
                    this.starMesh.rotation.y = time * 0.5;
                    this.starMesh.rotation.z = time * 0.2;
                    const hue = 0.14; 
                    const saturation = 1.0; 
                    const lightness = 0.5 + Math.abs(Math.sin(time * 3)) * 0.4; 
                    this.starMesh.material.color.setHSL(hue, saturation, lightness);
                }

                const baseZ = 90;
                const targetZ = baseZ / this.state.zoom;
                this.camera.position.z += (targetZ - this.camera.position.z) * 0.1;

                this.state.rotationSpeed += (this.state.targetRotationSpeed - this.state.rotationSpeed) * 0.1;
                this.scene.rotation.y += this.state.rotationSpeed * 0.05;

                let i = 0;
                
                for(const p of this.particles) {
                    let target = (this.state.mode === 'morphing') ? null : (this.targetPositions[i] || p.current);
                    if (target) {
                        let finalTarget = target.clone();
                        if (this.state.mode === 'text') {
                             const waveY = Math.sin(time * 3.0 + finalTarget.x * 0.2) * 1.5;
                             const waveZ = Math.cos(time * 2.0 + finalTarget.x * 0.2) * 0.5;
                             finalTarget.y += waveY;
                             finalTarget.z += waveZ;
                        }
                        const diff = finalTarget.sub(p.current);
                        const dist = diff.length();
                        if(dist > 0.05) {
                            diff.normalize().multiplyScalar(dist * p.speed);
                            p.current.add(diff);
                        }
                    } else {
                        p.current.add(p.velocity);
                        p.velocity.multiplyScalar(0.96);
                    }
                    this.dummy.position.copy(p.current);
                    let s = p.baseScale;
                    if (!p.isGreen) s *= (0.8 + Math.sin(time * 5 + p.phase) * 0.4);
                    if (this.state.mode === 'text') { s *= 1.2 + Math.sin(time * 10 + p.phase) * 0.3; }
                    this.dummy.scale.setScalar(s);
                    this.dummy.lookAt(this.camera.position);
                    this.dummy.updateMatrix();
                    this.instancedMesh.setMatrixAt(i, this.dummy.matrix);
                    i++;
                }
                this.instancedMesh.instanceMatrix.needsUpdate = true;

                const globalScale = this.state.frameScale;
                
                if (this.state.mode === 'tree' || this.state.mode === 'morphing') {
                    this.frames.forEach((f, idx) => {
                        const y = f.baseY;
                        let baseR = Math.pow((35 - y) / 75, 0.8) * 18 + 2; 
                        
                        let targetScale = globalScale;
                        let targetIntensity = THREE.MathUtils.mapLinear(globalScale, 1.0, 3.0, 0.2, 2.5);
                        let pushOut = (globalScale - 1) * 8;

                        f.currentScale += (targetScale - f.currentScale) * 0.1;

                        const r = baseR + pushOut;
                        const theta = f.baseTheta + time * 0.1; 
                        
                        f.mesh.position.set(Math.cos(theta)*r, y, Math.sin(theta)*r);
                        f.mesh.lookAt(0, y, 0);
                        f.mesh.rotateY(Math.PI); 
                        
                        f.mesh.scale.setScalar(f.currentScale);
                        f.mesh.visible = true;

                        const borderMesh = f.mesh.children[0];
                        if (borderMesh && borderMesh.material) {
                            borderMesh.material.emissiveIntensity = targetIntensity;
                        }
                    });
                } else {
                    this.frames.forEach(f => f.mesh.visible = false);
                }

                const snPos = this.snowSystem.geometry.attributes.position.array;
                for(let j=0; j<this.config.snowCount; j++){
                    snPos[j*3+1] -= this.snowVel[j].y;
                    snPos[j*3] += Math.sin(time + this.snowVel[j].sway) * 0.1;
                    if(snPos[j*3+1] < -100) {
                        snPos[j*3+1] = 100;
                        snPos[j*3] = (Math.random()-0.5)*300;
                    }
                }
                this.snowSystem.geometry.attributes.position.needsUpdate = true;

                this.composer.render();
            }

            onResize() {
                this.camera.aspect = window.innerWidth/window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.composer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        const app = new ChristmasGestures();
        window.app = app;
    </script>
</body>
</html>
